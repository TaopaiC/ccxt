# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import base64
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound


class max(Exchange):

    def describe(self):
        return self.deep_extend(super(max, self).describe(), {
            'id': 'max',
            'name': 'Max',
            'countries': ['TW'],
            'version': 'v2',
            'rateLimit': 1200,
            'certified': False,
            'has': {
                'CORS': True,
                'publicAPI': True,
                'privateAPI': True,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'createDepositAddress': True,
                'createLimitOrder': True,
                'createMarketOrder': True,
                'createOrder': True,
                'deposit': False,
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': True,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '6h': '360',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': '',
                'api': {
                    'web': 'https://max.maicoin.com',
                    'wapi': '',
                    'public': 'https://max-api.maicoin.com',
                    'private': 'https://max-api.maicoin.com',
                },
                'www': 'https://max.maicoin.com',
                'doc': 'https://max.maicoin.com/documents/api',
                'fees': 'https://max.maicoin.com/docs/fees',
            },
            'api': {
                'web': {
                },
                'wapi': {
                },
                'public': {
                    'get': [
                        'markets',
                        'currencies',
                        'tickers/{market_id}',
                        'tickers',
                        'withdrawal/constraint',
                        'depth',
                        'trades',
                        'k',
                        'timestamp',
                    ],
                },
                'private': {
                    'get': [
                        'members/profile',
                        'members/accounts/{currency_id}',
                        'members/accounts',
                        'members/me',
                        'deposits',
                        'deposit',
                        'deposit_addresses',
                        'withdrawals',
                        'withdrawal',
                        'withdrawal_addresses',
                        'orders',
                        'order',
                        'trades/my/of_order',
                        'trades/my',
                        'internal_transfers',
                        'internal_transfer',
                        'rewards/{reward_type}',
                        'rewards',
                        'max_rewards/yesterday',
                    ],
                    'post': [
                        'deposit_addresses',
                        'orders/clear',
                        'orders',
                        'orders/multi',
                        'order/delete',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.05 / 100,
                    'taker': 0.15 / 100,
                },
                'funding': {
                    'withdraw': {},
                    'deposit': {},
                },
            },
            'commonCurrencies': {
            },
            'options': {
                'timeDifference': 0,  # the difference between system clock and Binance clock
                'adjustForTimeDifference': False,  # controls the adjustment logic upon instantiation
            },
            'exceptions': {
                '2004': OrderNotFound,
                '2005': AuthenticationError,  # Signature is incorrect.
                '2006': AuthenticationError,  # The nonce has already been used by access key.
                '2007': AuthenticationError,  # The nonce is invalid.(30 secconds difference from server time)
                '2008': AuthenticationError,  # The access key does not exist.
                '2009': AuthenticationError,  # The access key is disabled.
                '2011': AuthenticationError,  # Requested API is out of access key scopes.
                '2014': AuthenticationError,  # Payload is not consistent with body or wrong path in payload.
                '2015': AuthenticationError,  # Payload is invalid
                '2016': InvalidOrder,  # amount_too_small
                '2018': InsufficientFunds,  # cannot lock funds
            },
        })

    def nonce(self):
        return self.milliseconds() - self.options['timeDifference']

    def load_time_difference(self):
        serverTimestamp = self.publicGetTimestamp()
        after = self.milliseconds()
        self.options['timeDifference'] = after - int(serverTimestamp, 10) * 1000
        return self.options['timeDifference']

    def insert_objects_property_by(self, a, keyA, b, keyB, insertKey):
        result = {}
        for i in range(0, len(a)):
            entry = a[i]
            index = entry[keyA]
            result[index] = entry
        for i in range(0, len(b)):
            entry = b[i]
            index = entry[keyB]
            if result[index]:
                result[index][insertKey] = entry
        values = []
        resultKeys = list(result.keys())
        for i in range(0, len(resultKeys)):
            values.append(result[resultKeys[i]])
        return values

    def fetch_currencies(self, params={}):
        currenciesResponse = self.publicGetCurrencies(params)
        withdrawalResponse = self.publicGetWithdrawalConstraint()
        response = self.insert_objects_property_by(
            currenciesResponse,
            'id',
            withdrawalResponse,
            'currency',
            'withdrawal'
        )
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = currency['id']
            code = self.safe_currency_code(id)
            fiat = id is True if 'twd' else False
            withdrawal = self.safe_value(currency, 'withdrawal')
            withdrawalFee = self.safe_value(withdrawal, 'fee')
            withdrawalLimit = self.safe_value(withdrawal, 'min_amount')
            result[code] = {
                'id': id,
                'code': code,
                'name': code,
                'active': True,
                'fiat': fiat,
                'precision': self.safe_integer(currency, 'precision'),
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'deposit': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': withdrawalLimit,
                        'max': None,
                    },
                },
                'funding': {
                    'withdraw': {
                        'fee': withdrawalFee,
                    },
                    'deposit': {
                        'fee': None,
                    },
                },
                'info': currency,
            }
        return result

    def fetch_markets(self, params={}):
        markets = self.publicGetMarkets()
        if self.options['adjustForTimeDifference']:
            self.load_time_difference()
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = market['id']
            baseId = market['base_unit']
            quoteId = market['quote_unit']
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': market['base_unit_precision'],
                'price': market['quote_unit_precision'],
            }
            active = True
            entry = {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            }
            result.append(entry)
        return result

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetMembersAccounts(params)
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currency = balance['currency']
            if currency in self.currencies_by_id:
                currency = self.currencies_by_id[currency]['code']
            account = self.account()
            account['free'] = self.safe_float(balance, 'balance')
            account['used'] = self.safe_float(balance, 'locked')
            account['total'] = self.sum(account['free'], account['used'])
            result[currency] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit  # default = 300
        response = self.publicGetDepth(self.extend(request, params))
        timestamp = self.safe_timestamp(response, 'timestamp')
        orderbook = self.parse_order_book(response, timestamp)
        return orderbook

    def parse_ticker(self, ticker, tickerSymbol, market=None):
        timestamp = self.safe_timestamp(ticker, 'at')
        symbol = self.find_symbol(tickerSymbol, market)
        last = self.safe_float(ticker, 'last')
        open = self.safe_float(ticker, 'open')
        change = last - open
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'buy'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'sell'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': (change / open) * 100,
            'average': (last + open) / 2,
            'baseVolume': self.safe_float(ticker, 'vol'),
            'quoteVolume': None,
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        response = self.publicGetTickersMarketId(self.extend({
            'market_id': market['id'],
        }, params))
        return self.parse_ticker(response, market['id'], market)

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        tickerKeys = list(rawTickers.keys())
        for i in range(0, len(tickerKeys)):
            key = tickerKeys[i]
            rawTicker = rawTickers[key]
            tickers.append(self.parse_ticker(rawTicker, key))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        rawTickers = self.publicGetTickers(params)
        return self.parse_tickers(rawTickers, symbols)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            ohlcv[0],
            float(ohlcv[1]),
            float(ohlcv[2]),
            float(ohlcv[3]),
            float(ohlcv[4]),
            float(ohlcv[5]),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'period': self.timeframes[timeframe],
        }
        if since is not None:
            request['timestamp'] = since
        if limit is not None:
            request['limit'] = limit  # default = 30
        response = self.publicGetK(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_deposit_address(self, code, response):
        depositAddress = None
        if len(response) <= 1:
            depositAddress = response[0]
        else:
            # TODO for multiple deposit address
            depositAddress = response[0]
        address = self.safe_string(depositAddress, 'address')
        tag = None
        if code == 'XRP' and address:
            splitted = address.split('?dt=')
            address = splitted[0]
            tag = splitted[1]
        self.check_address(address)
        return {
            'info': response,
            'currency': code,
            'address': address,
            'tag': tag,
        }

    def create_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privatePostDepositAddresses(self.extend(request, params))
        return self.parse_deposit_address(code, response)

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetDepositAddresses(self.extend(request, params))
        return self.parse_deposit_address(code, response)

    def parse_transaction_status_by_type(self, status, type=None):
        if type is None:
            return status
        statuses = {
            'deposit': {
            },
            'withdrawal': {
                'sent': 'pending',
                'confirmed': 'ok',
            },
        }
        return statuses[type][status] if (status in statuses[type]) else status

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'uuid')
        txid = self.safe_string(transaction, 'txid')
        # print('currency', currency)
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        timestamp = self.safe_timestamp(transaction, 'created_at')
        updated = self.safe_timestamp(transaction, 'updated_at')
        amount = self.safe_float(transaction, 'amount')
        feeCurrencyId = self.safe_string(transaction, 'currency')
        feeCurrency = None
        if feeCurrencyId in self.currencies_by_id:
            feeCurrency = self.currencies_by_id[feeCurrencyId]
        if feeCurrency is not None:
            feeCurrencyId = feeCurrency['code']
        else:
            feeCurrencyId = self.safe_currency_code(feeCurrencyId)
        fee = {
            'cost': self.safe_float(transaction, 'fee'),
            'currency': feeCurrencyId,
        }
        # TODO type
        type = 'withdrawal'
        status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'state'), type)
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': None,
            'tag': None,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': fee,
        }

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        request = {}
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        # timestamp : the seconds elapsed since Unix epoch, set to return trades executed before the time only
        # if timestamp is not None:
        #     request['timestamp'] = timestamp
        # }
        response = self.privateGetWithdrawals(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = None
        request = {}
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        response = self.privateGetWithdrawals(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # public trades
        #
        #    {
        #        "id": 4813073,
        #        "price": "3980.0",
        #        "volume": "0.000264",
        #        "funds": "1.05072",
        #        "market": "btcusdt",
        #        "market_name": "BTC/USDT",
        #        "created_at": 1553341297,
        #        "side": "bid"
        #    }
        #
        #
        # private trades
        #
        #    {
        #        "id": 3175037,
        #        "price": "3986.97",
        #        "volume": "0.125",
        #        "funds": "498.37125",
        #        "market": "btcusdt",
        #        "market_name": "BTC/USDT",
        #        "created_at": 1543941724,
        #        "side": "ask",
        #        "fee": "0.747557",
        #        "fee_currency": "usdt",
        #        "order_id": 18298466
        #    }
        timestamp = self.safe_timestamp(trade, 'created_at')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'volume')
        id = self.safe_integer(trade, 'id')
        side = self.safe_string(trade, 'side')
        order = self.safe_string(trade, 'order_id')
        fee = None
        if 'fee' in trade:
            fee = {
                'cost': self.safe_float(trade, 'fee'),
                'currency': self.safe_currency_code(trade['fee_currency']),
            }
        takerOrMaker = None  # TODO takerOrMaker
        symbol = None
        if market is None:
            marketId = self.safe_string(trade, 'market')
            market = self.safe_value(self.markets_by_id, marketId)
        if market is not None:
            symbol = market['symbol']
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': price * amount,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        # timestamp : the seconds elapsed since Unix epoch, set to return trades executed before the time only
        # if timestamp is not None:
        #     request['timestamp'] = timestamp
        # }
        if limit is not None:
            request['limit'] = limit  # default = 50, maximum = 1000
        response = self.publicGetTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        # timestamp : the seconds elapsed since Unix epoch, set to return trades executed before the time only
        # if since is not None:
        #     request['timestamp'] = since
        response = self.privateGetTradesMy(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            'wait': 'open',
            'cancel': 'canceled',
            'done': 'closed',
            'convert': 'open',  # TODO
            'finalizing': 'open',  # TODO
            'failed': 'canceled',  # TODO
        }
        return statuses[status] if (status in statuses) else status

    def parse_order(self, order):
        status = self.parse_order_status(self.safe_string(order, 'state'))
        symbol = self.find_symbol(self.safe_string(order, 'market'))
        timestamp = self.safe_timestamp(order, 'created_at')
        lastTradeTimestamp = self.safe_timestamp(order, 'updated_at')
        id = self.safe_integer(order, 'id')
        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'volume')
        average = self.safe_float(order, 'avg_price')
        filled = self.safe_float(order, 'executed_volume')
        cost = None
        remaining = self.safe_float(order, 'remaining_volume')
        type = self.safe_string(order, 'ord_type')
        if type is not None:
            if type == 'market':
                if price is None:
                    price = average
        if price is not None:
            cost = price * filled
        side = self.safe_string(order, 'side')
        result = {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': None,  # TODO fee of order
            'trades': None,  # TODO trades of order
        }
        return result

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        order = {
            'market': market['id'],
            'volume': self.amount_to_precision(symbol, amount),
            'ord_type': type,
            'side': side,
        }
        priceIsRequired = False
        stopPriceIsRequired = False
        if type == 'limit' or type == 'stop_limit':
            priceIsRequired = True
        if type == 'stop_limit' or type == 'stop_market':
            stopPriceIsRequired = True
        if priceIsRequired:
            if price is None:
                raise InvalidOrder(self.id + ' createOrder method requires a price argument for a ' + type + ' order')
            order['price'] = self.price_to_precision(symbol, price)
        if stopPriceIsRequired:
            stopPrice = self.safe_float(params, 'stopPrice')
            if stopPrice is None:
                raise InvalidOrder(self.id + ' createOrder method requires a stopPrice extra param for a ' + type + ' order')
            params = self.omit(params, 'stopPrice')
            order['stopPrice'] = self.price_to_precision(symbol, stopPrice)
        response = self.privatePostOrders(self.extend(order, params))
        return self.parse_order(response, market)

    def cancel_all_orders(self, symbol=None, params={}):
        request = {}
        if symbol is not None:
            self.load_markets()
            market = self.market(symbol)
            request['market'] = market['id']
        return self.privatePostOrdersClear(self.extend(request, params))

    def cancel_order(self, id, symbol=None, params={}):
        request = {
            'id': id,
        }
        response = self.privatePostOrderDelete(self.extend(request, params))
        return self.parse_order(response)

    def fetch_order(self, id, symbol=None, params={}):
        if id is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a id argument')
        self.load_markets()
        request = {
            'id': id,
        }
        response = self.privateGetOrder(request)
        return self.parse_order(response)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrders requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(response, market, None, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        return self.fetch_orders(symbol, since, limit, self.extend(params, {'state': 'done'}))

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        return self.fetch_orders(symbol, since, limit, self.extend(params, {'state': 'wait'}))

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        newParams = params
        request = '/api/' + self.version + '/' + self.implode_params(path, params)
        url = self.urls['api'][api]
        url += request
        if api == 'private':
            self.check_required_credentials()
            newParams = self.extend(params, {
                'nonce': self.nonce(),
                'path': request,
            })
            payload = base64.b64encode(self.json(newParams))
            signature = self.hmac(payload, self.secret)
            if not headers:
                headers = {}
            headers = self.extend(headers, {
                'X-MAX-ACCESSKEY': self.apiKey,
                'X-MAX-PAYLOAD': payload,
                'X-MAX-SIGNATURE': signature,
            })
        if method == 'GET' or method == 'DELETE':
            if newParams:
                url += '?' + self.urlencode(newParams)
        else:
            body = self.json(newParams)
            if not headers:
                headers = {}
            headers = self.extend(headers, {
                'Content-Type': 'application/json',
            })
        return {
            'url': url,
            'method': method,
            'body': body,
            'headers': headers,
        }

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        error = self.safe_string(response, 'error')
        if isinstance(error, basestring):
            return
        code = error and self.safe_string(error, 'code')
        if code:
            feedback = self.id + ' ' + self.safe_string(error, 'message')
            if code in self.exceptions:
                raise self.exceptions[code](feedback)
            else:
                raise ExchangeError(feedback)
